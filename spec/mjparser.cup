package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.as.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;
import java.io.*;
import java.util.*;


parser code {:


	Logger log = Logger.getLogger(getClass());

    boolean errorDetected = false;
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_semantic_error(int line, String description){
        StringBuilder msg = new StringBuilder("Semanticka greska na liniji ");
        if(description != null){
            msg.append(line).append(": ");
            msg.append(description);
        }
        log.error(msg.toString());
        errorDetected = true;
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

//    String kindToString(int kind){
//        StringBuilder msg = new StringBuilder();
//        switch(kind){
//            case Obj.Con: msg.append("Con");break;
//            case Obj.Var: msg.append("Var");break;
//            case Obj.Type: msg.append("Type");break;
//            case Obj.Meth: msg.append("Meth");break;
//            case Obj.Fld: msg.append("Fld");break;
//            case Obj.Elem: msg.append("Elem");break;
//            case Obj.Prog: msg.append("Prog");break;
//            case Obj.NO_VALUE: msg.append("RVALUE");break;
//        }
//        return msg.toString();
//    }
//
//    String structToString(Struct s){
//        StringBuilder msg = new StringBuilder();
//        switch(s.getKind()){
//            case Struct.None: msg.append("None(VOID)");break;
//            case Struct.Int: msg.append("Int");break;
//            case Struct.Char: msg.append("Char");break;
//            case Struct.Array: msg.append("Array of ").append(structToString(s.getElemType()));break;
//            case Struct.Class: msg.append("Class");break;
//            case Struct.Bool: msg.append("Bool");break;
//        }
//        return msg.toString();
//    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
    MojaTabela.mojaInicijalizacija();
	//Tab.init(); // Universe scope

    //definicija metoda
    Tab.find("chr").setAdr(Code.pc);
    Code.put(Code.enter);
    Code.put(1);
    Code.put(1);
    Code.put(Code.load_n);
    Code.put(Code.exit);
    Code.put(Code.return_);

    Tab.find("ord").setAdr(Code.pc);
    Code.put(Code.enter);
    Code.put(1);
    Code.put(1);
    Code.put(Code.load_n);
    Code.put(Code.exit);
    Code.put(Code.return_);

    Tab.find("len").setAdr(Code.pc);
    Code.put(Code.enter);
    Code.put(1);
    Code.put(1);
    Code.put(Code.load_n);
    Code.put(Code.arraylength);
    Code.put(Code.exit);
    Code.put(Code.return_);
:}

action code {:
	Obj currentMethod = null;
	MojaKlasa mk = new MojaKlasa();

	boolean inFunction = false;
	boolean inMain = false;
	Struct constType = null;

	boolean returnFound = false;

	//brojanje parametara
	int numOfParameters = 0;

    //da li je ime deklarisano u trenutnom opsegu
    boolean checkName(String name){
        return Tab.currentScope().findSymbol(name) == null;
    }

    Stack<List<Obj>> actualParamsList = new Stack<List<Obj>>();
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ;
terminal RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUALEQUAL, NOTEQUAL, LESS, LESSOREQUAL, AND, OR;
terminal EQUAL, PLUSEQUAL, MINUSEQUAL, DIVEQUAL, MODEQUAL, PLUSPLUS, MINUSMINUS;
terminal SEMI, COMMA, DOT, SQUAREBRACKETLEFT, SQUAREBRACKETRIGHT, LBRACE, RBRACE, LPAREN, RPAREN;
terminal ANDAND, OROR, MOREOREQUAL, MORE, MULEQUAL;

terminal Boolean BOOL;
terminal Character CHAR;
terminal Integer NUMBER ;
terminal String IDENT ;


non terminal Program, MethodDeclList, MethodDecl;
non terminal VarDeclList, VarDecl,DeclList, ConstDecl, ClassDecl, ConstDeclList;
non terminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList;
non terminal StatementList, Statement;
/*
NON TERMINAL OBJECTS
*/
non terminal Obj Designator, Factor, Expr, Term, ComboExpr, AddTerm;
/*
NON TERMINAL Structs
*/
non terminal Struct Type, MethodType;

non terminal Obj ConstVal;

non terminal Unmatched, Matched;
non terminal VarDecElem, VarDecElemList;
non terminal Assignop, Relop;
non terminal Condition, CondTerm, CondFact;
non terminal Integer Addop, AddopLeft, AddopRight, Mulop, MulopRight, MulopLeft , CombOp;



Program ::= PROG IDENT:pName
            {:
                MojaTabela.insert(Obj.Prog,pName,Tab.noType);
                Tab.openScope();
            :}
            DeclList LBRACE MethodDeclList RBRACE
            {:
                if(!parser.errorDetected)
                    Code.dataSize = Tab.currentScope().getnVars();

                Tab.chainLocalSymbols(Tab.find(pName));
                Tab.closeScope();
                String tmp = mk.dump();
                System.out.println(tmp);
                Tab.dump(new MojTableVisitor());
                if(!parser.errorDetected){
                    parser.log.info("Parsiranje uspesno zavrseno!");
                    File objFile = new File("test/program.obj");
                    if(objFile.exists())
                        objFile.delete();
                    if(!parser.errorDetected)
                        Code.write(new FileOutputStream(objFile));
                }
                else
                    parser.log.error("Parsiranje NIJE uspesno zavrseno!");
            :} ;

VarDeclList ::= VarDeclList VarDecl
				|
				/* epsilon */
				;
DeclList ::= DeclList VarDecl
				|
				DeclList ConstDecl
				|
				DeclList ClassDecl
				|
				/* epsilon */
				;
VarDecl ::=     Type:cType
                {:
                    constType = cType;
                :}
                VarDecElemList SEMI;

VarDecElem ::= IDENT:varName
                {:
                    //parser.report_error("****************************************" + varName, null);
                    if(inFunction != true){
                        mk.globalVars++;
                    }
                    if(inMain == true){
                        mk.inMainVars++;
                    }
                    if(Tab.currentScope().findSymbol(varName) != null)
                    {
                        parser.report_error("Greska na liniji " + varNameleft + " vec postoji simbol sa imenom: " + varName, null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                        parser.report_info("Deklarisana promenljiva '" + varName + "' na liniji " + varNameleft, null);
                        Tab.insert(Obj.Var, varName, constType);
                    }
                :}
                |
                IDENT:varName SQUAREBRACKETLEFT SQUAREBRACKETRIGHT
                {:
                    if(inFunction != true){
                        mk.globalVars++;
                    }
                    if(inMain == true){
                        mk.inMainVars++;
                    }
                    if(Tab.currentScope().findSymbol(varName) != null)
                    {
                           parser.report_error("Greska na liniji " + varNameleft + " vec postoji simbol sa imenom: " + varName, null);
                           RESULT = Tab.noObj; //NULL...
                       }
                       else
                       {
                           parser.report_info("Deklarisana promenljiva tipa niz '" + varName + "' na liniji " + varNameleft, null);
                           Tab.insert(Obj.Var, varName,new Struct(Struct.Array, constType));
                       }
                   :};

VarDecElemList ::=  VarDecElem COMMA VarDecElemList
					|
					VarDecElem
					|
					error:err COMMA VarDecElemList
					{:

						parser.report_error("Sintaksna greska na liniji " + errleft + " pogresna deklaracija globalne promenljive | ZAREZ!" , null);
						parser.report_info("Uspesan oporovak od greske na liniji " + errleft + "."  , null);
					:}
					|
					error:err
					{:
						parser.report_error("Sintaksna greska na liniji " + errleft + " pogresna deklaracija globalne promenljive!" , null);
						parser.report_info("Uspesan oporovak od greske na liniji " + errleft + "."  , null);
					:}
					;



ConstVal ::= NUMBER:num
            {:
                mk.globalConsts++;
                RESULT =  new Obj(Obj.Con, "", Tab.intType, num, Obj.NO_VALUE);


            :}
			 |
			 BOOL:bo
            {:
                mk.globalConsts++;
                RESULT = new Obj(Obj.Con, "", MojaTabela.boolType, bo?1:0, Obj.NO_VALUE);
            :}
			 |
			 CHAR:c
            {:
                mk.globalConsts++;
                RESULT = new Obj(Obj.Con, "", Tab.charType, c, Obj.NO_VALUE);
            :}
            NUMBER:num
			 ;
ConstDecl ::= CONST Type:cType
                {:
                    constType = cType;
                :}
                ConstDeclList SEMI
                |
                CONST error:e SEMI {: parser.report_error("Greska na liniji " + eleft + " : " + "losa deklaracija konstante" ,null); :};

ConstDeclList ::= IDENT:constName EQUAL ConstVal:type
                    {:
                        if(type.getType() != constType)
                        {
                            parser.report_error("Greska na liniji " + constNameleft + " nekompatibilni tipovi", null);
                            RESULT = Tab.noObj; //NULL...
                        }
                        else if(Tab.currentScope().findSymbol(constName) == Tab.noObj)
                        {
                            parser.report_error("Greska na liniji " + constNameleft + " vec postoji simbol sa imenom: " + constName, null);
                            RESULT = Tab.noObj; //NULL...
                        }
                        else
                        {
                            Obj obj=Tab.insert(Obj.Con, constName, constType);
                            obj.setAdr(type.getAdr());
                        }
                    :}
                    COMMA ConstDeclList
				  |
				  IDENT:constName EQUAL ConstVal:type
				  {:
                      if(type.getType() != constType)
                      {
                          parser.report_error("Greska na liniji " + constNameleft + " nekompatibilni tipovi", null);
                          RESULT = Tab.noObj; //NULL...
                      }
                      else if(Tab.currentScope().findSymbol(constName) == Tab.noObj)
                      {
                          parser.report_error("Greska na liniji " + constNameleft + " vec postoji simbol sa imenom: " + constName, null);
                          RESULT = Tab.noObj; //NULL...
                      }
                      else
                      {
                          Obj obj=Tab.insert(Obj.Con, constName, constType);
                          obj.setAdr(type.getAdr());
                      }
                  :}
				  ;

Type ::= IDENT:ident
		{:
		    Obj obj = Tab.find(ident);
		    if(obj.getKind() != Obj.Type)
		    {
		         parser.report_error("Greska na liniji " + identleft+ ": "  + ident + " nema tip", null);
		         RESULT=Tab.noType;
		    }
		    else
		        RESULT = obj.getType();
		:};

MethodType ::= Type:type
                {: RESULT = type; :}
			   |
			   VOID
			   {: RESULT = Tab.noType; :};

MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::=  MethodType:type IDENT:funName
                {:
                    currentMethod = MojaTabela.insert(Obj.Meth,funName,type);
                    currentMethod.setLevel(0);
                    parser.report_info("Obradjuje se funkcija: " + funName + " na liniji " + funNameleft, null);
                    Tab.openScope();

                :}
                LPAREN FormPars:formPars RPAREN
                 {:
                     inFunction = true;
                     if(funName.equals("main")){
                         inMain = true;
                     }
                 :} VarDeclList LBRACE
                {:

                    if(!parser.errorDetected)
                        currentMethod.setAdr(Code.pc);
                    if("main".equals(funName)){
                        if(!parser.errorDetected)
                            Code.mainPc = currentMethod.getAdr();
                    }

                    if(!parser.errorDetected){
                        Code.put(Code.enter);
                        Code.put(currentMethod.getLevel()); //broj argumenata enter funkcije //drugi operand koliko ukupno arg i lok prom a prvi da
                        Code.put(Tab.currentScope().getnVars()-currentMethod.getLevel()); //daje broj promenljivih
                    }



                    if(currentMethod.getName().equals("main") && currentMethod.getLevel() > 0){
                        parser.report_semantic_error(formParsleft, "Metoda main ne sme imati parametre.");
                    }

                    //TODO ovde ide gen koda za ulaz u metodu

                :}
                StatementList RBRACE
                {:
                    if(!returnFound && type != Tab.noType && inMain == false)  //ovo je i za void
                        parser.report_error("Semanticka greska na liniji " + typeleft + ": funkcija " + funName + " nema RETURN iskaz", null); //CHECK return iskaz
                    if(type != Tab.noType && inMain == true){
                        parser.report_error("Semanticka greska na liniji " + typeleft + ": funkcija " + funName + " mora biti VOID!", null); //CHECK return iskaz
                    }

                    if(!parser.errorDetected){
                        Code.put(Code.exit); //zavrsne instrukcije metode
                        Code.put(Code.return_);
                    }

                    Tab.chainLocalSymbols(Tab.find(funName));
                    Tab.closeScope();
                    if(type!= Tab.noType){
                        if(!parser.errorDetected){
                            Code.put(Code.exit);
                            Code.put(Code.return_);
                        }
                    }
                    else {
                        if(!parser.errorDetected){
                            Code.put(Code.trap);
                            Code.put(1);
                        }
                    }

                    inFunction = false;
                    inMain = false; //ovo treba posle closeScope!
                    currentMethod = null;
                    returnFound = false;
                :};

FormPars ::= FormalParamList | /* epsilon */ ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl
					|
					FormalParamDecl
					;

FormalParamDecl ::= Type:type IDENT:ident
 {:
    if(Tab.currentScope().findSymbol(ident) == Tab.noObj)
    {
        parser.report_error("Greska na liniji " + typeleft + " vec postoji simbol sa imenom: " + ident, null);
        RESULT = Tab.noObj;
    }
    else
    {
        numOfParameters++;
        Tab.insert(Obj.Var, ident, type);
        currentMethod.setLevel(currentMethod.getLevel()+1);
    }
 :}
 |
 Type:type IDENT:ident SQUAREBRACKETLEFT SQUAREBRACKETRIGHT
  {:
     if(Tab.currentScope().findSymbol(ident) == Tab.noObj)
     {
         parser.report_error("Greska na liniji " + typeleft + " vec postoji simbol sa imenom: " + ident, null);
         RESULT = Tab.noObj;
     }
     else
     {
         numOfParameters++;
         Tab.insert(Obj.Var, ident, new Struct(Struct.Array, type));
         currentMethod.setLevel(currentMethod.getLevel()+1);
     }
  :}
  ;

StatementList ::= StatementList Statement
					|
				  /* epsilon */
				  ;

Statement ::= Matched
				|
			  Unmatched ;

Unmatched ::= IF Expr Statement
			|
			IF Expr Matched ELSE Unmatched
			;


Matched ::= Designator:destination EQUAL Expr:expression SEMI
            {:
                //provera za dodelu vr
                if(!expression.getType().assignableTo(destination.getType())){
                    parser.report_error("Greska na liniji: " + destinationleft + " : nekompatibilni tipovi u dodeli vrednosti", null); //CHECK THIS
                }
                else {
                    //generisati kod
                    if(!parser.errorDetected)
                        Code.store(destination); //X=5 (5 je destination)
                }

            :}
            |
            Designator:dest
            {:
                if(dest.getKind()!=Obj.Var && dest.getKind()!=Obj.Elem)
                    parser.report_error("Greska na liniji " + destleft + ": "+dest.getName()+" nije promenljiva!", null); //bodovi = (niz[1]/=niz[0]);
                else if(dest.getKind()==Obj.Var){
                    if(!parser.errorDetected)
                        Code.load(dest);
                }
                else if( dest.getKind() == Obj.Elem)
                {
                    if(!parser.errorDetected){
                        Code.put(Code.dup2);
                        Code.load(dest);
                    }
                }
             :}
            CombOp:op Expr:expr SEMI
            {:
                if(dest.getType() != Tab.intType || expr.getType() != Tab.intType){
                      parser.report_error("Greska na liniji " + destleft + ": nije int tipa! " , null); //bodovi = (niz[1]/=niz[0]);
                }
                else
                {
                    if(!parser.errorDetected){
                        Code.put(op);
                        Code.store(dest);
                    }
                }

            :}
            |
            Designator:des EQUAL error SEMI
            {: parser.log.debug("Izraz tipa: nesto = XX; XX je lose. Uspesan oporavak od greske pri dodeli vrednosti. Linija: " + desleft); :}
            |
            Designator:des PLUSPLUS SEMI
            {:
                if(des.getKind() != Obj.Con && des.getKind() != Obj.Meth && des.getKind() != Obj.NO_VALUE){
                    if(des.getType().getKind() == Struct.Int){ //CHECK sta ako je array ili elemArray, bool, char??
                        RESULT = des;

                        if(!parser.errorDetected){
                            if(des.getKind() == Obj.Elem){
                                Code.put(Code.dup2);
                            }
                            Code.load(des);
                            Code.loadConst(1);
                            Code.put(Code.add);
                            Code.store(des);
                        }
                    }
                    else{
                        parser.report_error("Promenljiva: " + des.getName() + " na liniji: " + desleft + " nije tipa int!",null);
                        RESULT = Tab.noObj;
                    }
                }
                else{
                    parser.report_error("Promenljiva: " + des.getName() + " na liniji: " + desleft + " nije tipa int!",null);
                    RESULT = Tab.noObj;
                }
            :}
            |
            Designator:des MINUSMINUS SEMI
            {:
                if(des.getKind() != Obj.Con && des.getKind() != Obj.Meth && des.getKind() != Obj.NO_VALUE){
                    if(des.getType().getKind() == Struct.Int){
                        RESULT = des;

                        if(!parser.errorDetected){
                            if(des.getKind() == Obj.Elem){
                                Code.put(Code.dup2);
                            }
                            Code.load(des);
                            Code.loadConst(1);
                            Code.put(Code.sub);
                            Code.store(des);
                        }
                    }
                    else{
                        parser.report_error("Promenljiva: " + des.getName() + " na liniji: " + desleft + " nije tipa int!",null);
                        RESULT = Tab.noObj;
                    }
                }
                else{
                    parser.report_error("Promenljiva: " + des.getName() + " na liniji: " + desleft + " nije tipa int!",null);
                    RESULT = Tab.noObj;
                }
            :}
            |
            Designator:func LPAREN
            {:
                actualParamsList.push(new ArrayList<Obj>());
            :}ActualPars RPAREN SEMI
            {:
                if (Obj.Meth == func.getKind())
                {
                    if(!actualParamsList.isEmpty()){
                        List<Obj> stvarniParametri = actualParamsList.pop();
                        Collection<Obj> formalniParametri = func.getLocalSymbols();//.getType().getMembers();
                        //if(formalniParametri.size() - func.getLevel() != stvarniParametri.size()){ //- func.getLevel() ovo predstavlja promenljive deklarisane u funkciji!
                        if(func.getLevel() != stvarniParametri.size()){ //- func.getLevel() ovo predstavlja promenljive deklarisane u funkciji!
                            parser.report_error("Ne slaze se broj stvarnih i formalnih parametara [linija: " + funcleft + "]", null);
                        }
                        else{
                            //OVDE PROVERA DA LI SU SVI ISTOG TIPA!
                            int i = 0;
                            for(Obj fp : formalniParametri){
                                if(i == stvarniParametri.size())
                                    break; //izadji pre nego sto krene da cita promenljive koje nisu argumenti!
                                if(fp.getType().getKind() != stvarniParametri.get(i++).getType().getKind()){
                                    parser.report_error("Ne slazu se tipovi stvarnih i formalnih parametara [linija: " + funcleft + "]", null);
                                    break;
                                }
                            }
                        }
                    } else {
                        parser.report_info("Funkcija: " + func.getName() + "nema argumente [linija: " + funcleft + "]", null);
                    }

                    parser.report_info("[Matched]Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
                    RESULT = func.getType();

                    if(!parser.errorDetected)
                    {
                        int destAdr = func.getAdr() - Code.pc; //PC relativna adresa
                        Code.put(Code.call);
                        Code.put2(destAdr); //PC relativan skok
                        if(func.getType() != Tab.noType){
                            Code.put(Code.pop); //skini vrednost sa expression steka
                        }
                    }
                }
                else{
                    parser.report_error("[Matched]Greska na liniji " + funcleft + " : ime " + func.getName() + " nije funkcija!", null);
                    RESULT = Tab.noType;
                }
            :}
            |
            READ LPAREN Designator:de RPAREN SEMI
            {:
               if(de.getKind() != Obj.Var && de.getKind() != Obj.Fld && de.getKind() != Obj.Elem){
                   parser.report_semantic_error(deleft, "Neocekivana kategorija simbola " + de.getName() +". Ocekivano: "+ "var elem ili field" +"; Dobijeno: "+ de.getType().getKind() +".");
               }
               if(de.getType().getKind() == Struct.Int || de.getType().getKind() == Struct.Bool || de.getType().getKind() == Struct.Char)
               {
                    RESULT = de;

                    if(!parser.errorDetected)
                    {
                        if(de.getType() == Tab.charType){
                            Code.put(Code.bread);
                        }else{
                            Code.put(Code.read);
                        }
                        Code.store(de);
                    }
               }
               else{
                    parser.report_semantic_error(deleft, "Argumenti READ funkcije moraju biti [int,char,bool].");
                    RESULT = Tab.noObj;
               }
            :}
            |
            PRINT LPAREN Expr:e COMMA NUMBER:num RPAREN SEMI
            {:
                if(e.getType().getKind() == Struct.Int || e.getType().getKind() == Struct.Bool && e.getType().getKind() == Struct.Char){
                    RESULT = e;

                    if(!parser.errorDetected){
                        Code.loadConst(num);
                        if(e.getType() == Tab.charType){
                            Code.put(Code.bprint);
                        }else{
                            Code.put(Code.print);
                        }
                    }
                    mk.printCallCount++;
                }
                else {
                    parser.report_semantic_error(eleft, "Argumenti PRINT funkcije moraju biti [int,char,bool].");
                    RESULT = Tab.noObj;
                };
            :}
            |
            PRINT LPAREN Expr:e RPAREN SEMI
            {:
                if(e.getType().getKind() == Struct.Int){
                    mk.printCallCount++;
                    RESULT = e; //CHECK RETURN
                    if(!parser.errorDetected){
                        Code.loadConst(5);
                        Code.put(Code.print);
                    }
                } else if(e.getType().getKind() == Struct.Char){
                    mk.printCallCount++;
                    if(!parser.errorDetected){
                        Code.loadConst(1);
                        Code.put(Code.bprint);
                    }
                }
                else{
                    parser.report_semantic_error(eleft, "Argumenti PRINT funkcije moraju biti [int,char,bool].");
                    RESULT = Tab.noObj;
                }

            :}
            |
            RETURN Expr:typeOfExpr SEMI
            {:
                returnFound = true;
                Obj currentMethodType = currentMethod;
                if(!currentMethodType.getType().compatibleWith(typeOfExpr.getType()))
                {
                    parser.report_error("Greska na liniji: " + typeOfExprleft + " : tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije: " + currentMethod.getName(), null);
                } //CHECK THIS
                if(!parser.errorDetected){
                    Code.put(Code.exit);
                    Code.put(Code.return_);
                }
            :}
            |
            RETURN:r SEMI
            {:
                if(currentMethod.getType() != Tab.noType){
                    parser.report_semantic_error(rleft, "Metoda "+currentMethod.getName()+" je deklarisana da vraca vrednost");
                }

                if(!parser.errorDetected){
                    Code.put(Code.exit);
                    Code.put(Code.return_);
                }
            :}
            |
            IF Expr Matched ELSE Matched
            |
            LBRACE StatementList RBRACE
            ;

//Condition ::= CondTerm
//              |
//              CondTerm OROR CondTerm;

//CondTerm ::= CondFact
//             |
//             CondFact ANDAND CondFact;

//CondFact ::= Expr
//			 |
//			 Expr Relop Expr;



Factor ::=  Designator:des
			{:
                if(des.getKind()==Obj.Con){
                    if(!parser.errorDetected)
                        Code.load(des);
                }
				RESULT = des;
			:}
		    |
		   	Designator:func
		   	{:
		   	    actualParamsList.push(new ArrayList<Obj>());

		   	:}
		   	LPAREN ActualPars RPAREN
		   	{:
				if (Obj.Meth == func.getKind())
				{
				    if(!actualParamsList.isEmpty()){
                        List<Obj> stvarniParametri = actualParamsList.pop();
                        Collection<Obj> formalniParametri = func.getLocalSymbols();//.getType().getMembers();
                        //if(formalniParametri.size() - func.getLevel() != stvarniParametri.size()){ //- func.getLevel() ovo predstavlja promenljive deklarisane u funkciji!
                        if(func.getLevel() != stvarniParametri.size()){ //- func.getLevel() ovo predstavlja promenljive deklarisane u funkciji!
                            parser.report_error("Ne slaze se broj stvarnih i formalnih parametara [linija: " + funcleft + "]", null);
                        }
                        else{
                            //OVDE PROVERA DA LI SU SVI ISTOG TIPA!
                            int i = 0;
                            for(Obj fp : formalniParametri){
                                if(i == stvarniParametri.size())
                                    break; //izadji pre nego sto krene da cita promenljive koje nisu argumenti!
                                if(fp.getType().getKind() != stvarniParametri.get(i++).getType().getKind()){
                                    parser.report_error("Ne slazu se tipovi stvarnih i formalnih parametara [linija: " + funcleft + "]", null);
                                    break;
                                }
                            }
                        }
                    } else {
                        parser.report_info("Funkcija: " + func.getName() + "nema argumente [linija: " + funcleft + "]", null);
                    }
				    parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);

				    if(func.getType() == Tab.noType)
				        parser.report_semantic_error(funcleft,"Funkcija "+ func.getName()+  " ne moze da se koristi u izrazima jer nema povratnu vrednost.");
				    else{
				        if(!parser.errorDetected){
                            int destAdr = func.getAdr() - Code.pc; //PC relativna adresa
                            Code.put(Code.call);
                            Code.put2(destAdr); //PC relativan skok
                        }
				    }
                    RESULT = func;
                }
                else{
                    parser.report_error("Greska na liniji " + funcleft + " : ime " + func.getName() + " nije funkcija!", null);
                    RESULT = Tab.noObj;
                }
			:}
			|
			NUMBER:num
			{:
			    Obj obj =  new Obj(Obj.Con, "", Tab.intType, num, Obj.NO_VALUE);
                //Obj obj = Tab.insert(Obj.Con,"",Tab.intType); //CHECK NUMBER
                //obj.setAdr(num.intValue());
                if(!parser.errorDetected)
                    Code.load(obj);
				RESULT = obj;
			:}
			|
			CHAR:c
			{:
			    Obj obj = new Obj(Obj.Con, "", Tab.charType, c, Obj.NO_VALUE);
			    if(!parser.errorDetected)
			        Code.load(obj);
				RESULT = obj;
			:}
			|
			BOOL:bo
			{:
			    Obj obj = new Obj(Obj.Con, "", MojaTabela.boolType, bo?1:0, Obj.NO_VALUE);
                if(!parser.errorDetected)
			        Code.load(obj);
				RESULT = obj;
			:}
			|
			NEW Type:t
			{:
				if(t.getKind() != Struct.Class){
					parser.report_error("Greska na liniji " + tleft + " nije klasnog tipa", null);
					RESULT = Tab.noObj; //NULL...
				}
				else
				{
					RESULT = new Obj(Obj.Var,"",t);
				}
			:}
			|
			NEW Type:tname SQUAREBRACKETLEFT Expr:expr SQUAREBRACKETRIGHT
			{:
			    //parser.log.debug("NEW Tip: " + tname.getKind());
				if(expr.getType() != Tab.intType){
					parser.report_error("Greska na liniji " + tnameleft + " nije int tip[example: new int[5]]", null);
					RESULT = Tab.noObj;
				  }
				else {
					Struct struct = new Struct(Struct.Array, tname);
					RESULT = new Obj(Obj.Con, "", struct);

					if(!parser.errorDetected){
                        Code.put(Code.newarray);
                        if(tname == Tab.charType){
                            Code.put(0);
                        }else{
                            Code.put(1);
                        }
                    }
				}
			:}
			|
			LPAREN Expr:expr RPAREN
			{:
			    RESULT=expr;
			:}
		   ;

ActualPars ::= ActualParamList
				|
			   /* epsilon */
			   ;

ActualParamList ::= ActualParamList:apl COMMA Expr:e
                    {:
                        actualParamsList.peek().add(e);
                    :}
					|
					Expr:e
					 {:
                        actualParamsList.peek().add(e);
                    :}
					;

Designator ::=  IDENT:ident
                {:
                 Obj obj=Tab.find(ident);

                if(obj == Tab.noObj) {
                    parser.report_error("Greska na liniji " + identleft + " : ime " + ident + " nije deklarisano!", null);
                }

                if(obj.getKind()!=Obj.Var && obj.getKind()!=Obj.Con && obj.getKind()!=Obj.Meth ){
                    parser.report_error("Greska na liniji "+ " nije var, con, meth!!!!!!!!!!!"+obj.getKind(), null);
                    RESULT = Tab.noObj; //NULL...
                }else
                    RESULT=obj;

                :}
				|
				Designator DOT IDENT:ident
				{:
				    //nije ok, ako budem radio KLASE treba...
                    RESULT=Tab.find(ident);
                :}
				|
				Designator:des
				{:
                    if(des != Tab.noObj){
                        if(des.getType().getKind() != Struct.Array){
                            parser.report_semantic_error(desleft,"Simbol "+ des.getName()+  " ne predstavlja niz.");
                        }
                        else if(!parser.errorDetected) //CHECK maybe
                            Code.load(des);
                    }
				:}
				SQUAREBRACKETLEFT Expr:expr SQUAREBRACKETRIGHT
				{:
				    RESULT = Tab.noObj;
                    if(des != Tab.noObj){
                        boolean arrayOk = true;
                        if(des.getType().getKind() != Struct.Array){
                            arrayOk = false;
                        }
                        if(expr.getType() != Tab.intType){
                            parser.report_error("Tipovi se ne poklapaju! 1: " + des + " 2: " + expr, null);
                            arrayOk = false;
                        }

                        if(arrayOk){
                            //parser.log.debug("Designator tip(3 je array): " + des.getType().getKind() + " Expression tip(1 je int): " + expr.getType().getKind());
                            RESULT = new Obj(Obj.Elem, des.getName()+"[]", des.getType().getElemType(), des.getAdr(), des.getLevel());
                        }
                    }
				:};

Assignop ::= EQUAL | AddopRight | MulopRight;
//Relop ::= EQUALEQUAL | NOTEQUAL | MORE | MOREOREQUAL | LESS | LESSOREQUAL;

Expr ::= ComboExpr:expr
        {:  //nije int && nije char && nije bool
            if(expr.getType() != Tab.intType && expr.getType() != Tab.charType && expr.getType() != MojaTabela.boolType && expr.getType().getKind() != Struct.Array){
                parser.log.debug("Tip: " + expr.getType().getKind());
                parser.report_error("Greska na liniji " + exprleft + " nije int tipa | ID[1] => " + expr.getType().getKind(), null);
                RESULT = Tab.noObj;
            } else
            if(expr.getKind()==Obj.Var || expr.getKind()==Obj.Elem){
                if(!parser.errorDetected)
                    Code.load(expr);
            }
            RESULT = new Obj(Obj.Con, "", expr.getType());
        :}
         |
         MINUS ComboExpr:expr
         {:
            if(expr.getType() != Tab.intType){
                parser.report_error("Greska na liniji " + exprleft + " nije int tipa | ID[2]", null);
                RESULT = Tab.noObj;
            } else{
                if(expr.getKind()==Obj.Var || expr.getKind()==Obj.Elem){
                    if(!parser.errorDetected)
                        Code.load(expr);
                }
                if(!parser.errorDetected)
                    Code.put(Code.neg);
                RESULT = new Obj(Obj.Con, "", Tab.intType);
            }
         :};

ComboExpr ::=   AddTerm:addTerm
                {:
                if(addTerm.getKind()==Obj.Var){
                    if(!parser.errorDetected)
                        Code.load(addTerm);
                }
                if( addTerm.getKind() == Obj.Elem)
                {
                    if(!parser.errorDetected){
                        Code.put(Code.dup2);
                        Code.load(addTerm);
                    }
                }
                :}
                CombOp:op ComboExpr:comboExpr
                {:
                    if(addTerm.getKind() != Obj.Var && addTerm.getKind() != Obj.Elem){
                        parser.report_error("Greska na liniji " + addTermleft+ " nije varijabla(neocekivana kategorija simbola)", null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else if(addTerm.getType() != Tab.intType || comboExpr.getType() != Tab.intType){
                        parser.report_error("Greska na liniji " + addTermleft + " nije int tipa | ID[3]" + "addterm tip:" + addTerm.getType().getKind() + "comboExpr tip: " + comboExpr.getType().getKind(), null); //bodovi = (niz[1]/=niz[0]);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                        if(comboExpr.getKind()==Obj.Var || comboExpr.getKind()==Obj.Elem){
                            if(!parser.errorDetected)
                                Code.load(comboExpr);
                        }
                        if(!parser.errorDetected)
                            Code.put(op);
                         if(addTerm.getKind()==Obj.Var){
                            if(!parser.errorDetected)
                                Code.put(Code.dup);
                         }
                       if( addTerm.getKind()==Obj.Elem)
                       {
                            if(!parser.errorDetected)
                                Code.put(Code.dup_x2);
                       }

                       if(!parser.errorDetected)
                            Code.store(addTerm);
                        RESULT = new Obj(Obj.Con, "", Tab.intType);
                    }
                :}
				|
				AddTerm:addTerm
				{:
				    RESULT=addTerm;
				:};

AddTerm ::= AddTerm:addTerm
            {:
                if(addTerm.getKind()==Obj.Var || addTerm.getKind()==Obj.Elem){
                    if(!parser.errorDetected)
                        Code.load(addTerm);
                }
            :}
            AddopLeft:op Term:term
            {:
                if(addTerm.getType() != Tab.intType ||  term.getType() != Tab.intType){
                    parser.report_error("Greska na liniji " + addTermleft + " nije int tipa | ID[4]", null);
                    RESULT = Tab.noObj; //NULL...
                } else{
                    if(term.getKind()==Obj.Var || term.getKind()==Obj.Elem){
                        if(!parser.errorDetected)
                            Code.load(term);
                    }
                    if(!parser.errorDetected)
                        Code.put(op);
                    RESULT = new Obj(Obj.Con, "", Tab.intType);
                }
            :}
			|
            Term:term
            {:
                RESULT=term;
            :};

Term ::= Term:term
         {:
            if(term.getKind()==Obj.Var || term.getKind()==Obj.Elem){
                if(!parser.errorDetected)
                    Code.load(term);
            }
         :}
         MulopLeft:op Factor:factor
         {:
           //i ovde
            if(factor.getType() != Tab.intType || term.getType() != Tab.intType){
                parser.report_error("Greska na liniji " + termleft + " nije int tipa!", null);
                RESULT = Tab.noObj; //NULL...
            } else{
               if(factor.getKind()==Obj.Var || factor.getKind()==Obj.Elem){
                    if(!parser.errorDetected)
                        Code.load(term);
               }
               if(!parser.errorDetected)
                    Code.put(op);
               RESULT = new Obj(Obj.Con, "", Tab.intType);
            }
        :}
		|
		Factor:factor
		{:
		    RESULT=factor;
		:}
		;

CombOp ::= AddopRight:addri
            {:
                RESULT = addri;
            :}
		   |
		   MulopRight:mu
		   {:
		    RESULT = mu;
		   :};


Addop ::=   AddopLeft | AddopRight
            {:
            :};
AddopLeft ::= PLUS {: RESULT = Code.add; :}
              |
              MINUS {: RESULT = Code.sub; :};
AddopRight ::= PLUSEQUAL {: RESULT = Code.add; :}
               |
               MINUSEQUAL {: RESULT = Code.sub; :};

Mulop ::= MulopLeft | MulopRight;
MulopLeft ::=   MUL {: RESULT = Code.mul; :}
                |
                DIV {: RESULT = Code.div; :}
                |
                MOD {: RESULT = Code.rem; :};
MulopRight ::=  MULEQUAL
                {:
                    RESULT = Code.mul;
                :}
                |
                DIVEQUAL
                {:
                    RESULT = Code.div;
                :}
                |
                MODEQUAL
                {:
                    RESULT = Code.rem;
                :};

 
			  