package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.as.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;


parser code {:


	Logger log = Logger.getLogger(getClass());

    boolean errorDetected = false;
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_semantic_error(int line, String description){
        StringBuilder msg = new StringBuilder("Semanticka greska na liniji ");
        if(description != null){
            msg.append(line).append(": ");
            msg.append(description);
        }
        log.error(msg.toString());
        errorDetected = true;
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

    String kindToString(int kind){
        StringBuilder msg = new StringBuilder();
        switch(kind){
            case Obj.Con: msg.append("Con");break;
            case Obj.Var: msg.append("Var");break;
            case Obj.Type: msg.append("Type");break;
            case Obj.Meth: msg.append("Meth");break;
            case Obj.Fld: msg.append("Fld");break;
            case Obj.Elem: msg.append("Elem");break;
            case Obj.Prog: msg.append("Prog");break;
            case Obj.NO_VALUE: msg.append("RVALUE");break;
        }
        return msg.toString();
    }

    String structToString(Struct s){
        StringBuilder msg = new StringBuilder();
        switch(s.getKind()){
            case Struct.None: msg.append("None(VOID)");break;
            case Struct.Int: msg.append("Int");break;
            case Struct.Char: msg.append("Char");break;
            case Struct.Array: msg.append("Array of ").append(structToString(s.getElemType()));break;
            case Struct.Class: msg.append("Class");break;
            case Struct.Bool: msg.append("Bool");break;
        }
        return msg.toString();
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
    MojaTabela.mojaInicijalizacija();
	//Tab.init(); // Universe scope
:}

action code {:
	Obj currentMethod = null;
	MojaKlasa mk = new MojaKlasa();

	boolean inFunction = false;
	boolean inMain = false;
	Struct constType = null;

	boolean returnFound = false;

	//brojanje parametara
	int numOfParameters = 0;

    //da li je ime deklarisano u trenutnom opsegu
    boolean checkName(String name){
        return Tab.currentScope().findSymbol(name) == null;
    }
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ;
terminal RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUALEQUAL, NOTEQUAL, LESS, LESSOREQUAL, AND, OR;
terminal EQUAL, PLUSEQUAL, MINUSEQUAL, DIVEQUAL, MODEQUAL, PLUSPLUS, MINUSMINUS;
terminal SEMI, COMMA, DOT, SQUAREBRACKETLEFT, SQUAREBRACKETRIGHT, LBRACE, RBRACE, LPAREN, RPAREN;
terminal ANDAND, OROR, MOREOREQUAL, MORE, MULEQUAL;

terminal Boolean BOOL;
terminal Character CHAR;
terminal Integer NUMBER ;
terminal String IDENT ;


non terminal Program, MethodDeclList, MethodDecl;
non terminal VarDeclList, VarDecl,DeclList, ConstDecl, ClassDecl, ConstDeclList, ConstVal;
non terminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList;
non terminal StatementList, Statement;
/*
NON TERMINAL OBJECTS
*/
non terminal Obj Designator, Factor, Expr, Term, ComboExpr, AddTerm;
/*
NON TERMINAL Structs
*/
non terminal Struct Type, MethodType;


non terminal Unmatched, Matched;
non terminal VarDecElem, VarDecElemList;
non terminal Assignop, Relop;
non terminal Condition, CondTerm, CondFact;
non terminal Integer Addop, AddopLeft, AddopRight, Mulop, MulopRight, MulopLeft , CombOp;



Program ::= PROG IDENT:pName
            {:
                MojaTabela.insert(Obj.Prog,pName,Tab.noType);
                Tab.openScope();
            :}
            DeclList LBRACE MethodDeclList RBRACE
            {:
                Tab.chainLocalSymbols(Tab.find(pName));
                Tab.closeScope();
                String tmp = mk.dump();
                System.out.println(tmp);
                Tab.dump(new MojTableVisitor());
                if(!parser.errorDetected)
                    parser.log.info("Parsiranje uspesno zavrseno!");
                else
                    parser.log.error("Parsiranje NIJE uspesno zavrseno!");
            :} ;

VarDeclList ::= VarDeclList VarDecl
				|
				/* epsilon */
				;
DeclList ::= DeclList VarDecl
				|
				DeclList ConstDecl
				|
				DeclList ClassDecl
				|
				/* epsilon */
				;
VarDecl ::=     Type:cType
                {:
                    constType = cType;
                :}
                VarDecElemList SEMI;

VarDecElem ::= IDENT:varName
                {:
                    //parser.report_error("****************************************" + varName, null);
                    if(inFunction != true){
                        mk.globalVars++;
                    }
                    if(inMain == true){
                        mk.inMainVars++;
                    }
                    if(Tab.currentScope().findSymbol(varName) != null)
                    {
                        parser.report_error("Greska na liniji " + varNameleft + " vec postoji simbol sa imenom: " + varName, null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                        parser.report_info("Deklarisana promenljiva '" + varName + "' na liniji " + varNameleft, null);
                        Tab.insert(Obj.Var, varName, constType);
                    }
                :}
                |
                IDENT:varName SQUAREBRACKETLEFT SQUAREBRACKETRIGHT
                {:
                    if(inFunction != true){
                        mk.globalVars++;
                    }
                    if(inMain == true){
                        mk.inMainVars++;
                    }
                    if(Tab.currentScope().findSymbol(varName) != null)
                    {
                           parser.report_error("Greska na liniji " + varNameleft + " vec postoji simbol sa imenom: " + varName, null);
                           RESULT = Tab.noObj; //NULL...
                       }
                       else
                       {
                           parser.report_info("Deklarisana promenljiva tipa niz '" + varName + "' na liniji " + varNameleft, null);
                           Tab.insert(Obj.Var, varName,new Struct(Struct.Array, constType));
                       }
                   :};

VarDecElemList ::=  VarDecElem COMMA VarDecElemList
					|
					VarDecElem
					|
					error:err COMMA VarDecElemList
					{:

						parser.report_error("Sintaksna greska na liniji " + errleft + " pogresna deklaracija globalne promenljive | ZAREZ!" , null);
						parser.report_info("Uspesan oporovak od greske na liniji" + errleft + "."  , null);
					:}
					|
					error:err
					{:
						parser.report_error("Sintaksna greska na liniji " + errleft + " pogresna deklaracija globalne promenljive!" , null);
						parser.report_info("Uspesan oporovak od greske na liniji" + errleft + "."  , null);
					:}
					;



ConstVal ::= NUMBER
            {:
                mk.globalConsts++;
                RESULT = Tab.intType;
            :}
			 |
			 BOOL
            {:
                mk.globalConsts++;
                RESULT = MojaTabela.boolType;
            :}
			 |
			 CHAR
            {:
                mk.globalConsts++;
                RESULT = Tab.charType;
            :}
			 ;
ConstDecl ::= CONST Type:cType
                {:
                    constType = cType;
                :}
                ConstDeclList SEMI
                |
                CONST error:e SEMI {: parser.report_error("Greska na liniji " + eleft + " : " + "losa deklaracija konstante" ,null); :};

ConstDeclList ::= IDENT:constName EQUAL ConstVal:type
                    {:
                        if(type != constType)
                        {
                            parser.report_error("Greska na liniji " + constNameleft + " nekompatibilni tipovi", null);
                            RESULT = Tab.noObj; //NULL...
                        }
                        else if(Tab.currentScope().findSymbol(constName) == Tab.noObj)
                        {
                            parser.report_error("Greska na liniji " + constNameleft + " vec postoji simbol sa imenom: " + constName, null);
                            RESULT = Tab.noObj; //NULL...
                        }
                        else
                        {
                            Tab.insert(Obj.Con, constName, constType);
                        }
                    :}
                    COMMA ConstDeclList
				  |
				  IDENT:constName EQUAL ConstVal:type
				  {:
                    if(type != constType)
                    {
                        parser.report_error("Greska na liniji " + typeleft + " nekompatibilni tipovi", null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else if(Tab.currentScope().findSymbol(constName) == Tab.noObj)
                    {
                        parser.report_error("Greska na liniji " + typeleft + " vec postoji simbol sa imenom: " + constName, null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                    Tab.insert(Obj.Con, constName, constType);
                    }
				  :}
				  ;

Type ::= IDENT:ident
		{:
		    Obj obj = Tab.find(ident);
		    if(obj.getKind() != Obj.Type)
		    {
		         parser.report_error("Greska na liniji " + identleft+ ": "  + ident + " nema tip", null);
		         RESULT=Tab.noType;
		    }
		    else
		        RESULT = obj.getType();
		:};

MethodType ::= Type:type
                {: RESULT = type; :}
			   |
			   VOID
			   {: RESULT = Tab.noType; :};

MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::=  MethodType:type IDENT:funName
                {:
                    currentMethod = MojaTabela.insert(Obj.Meth,funName,type);
                    Tab.openScope();
                    parser.report_info("Obradjuje se funkcija: " + funName + " na liniji " + funNameleft, null);
                    //todo: neka promenljiva brPar=0;
                    //CHECK
                    int numOfParameters = 0;
                :}
                LPAREN
                {:
                    inFunction = true;
                    if(funName.equals("main")){
                        inMain = true;
                    }
                :}
                FormPars:formPars RPAREN
                {:
                    if(currentMethod.getName().equals("main") && currentMethod.getLevel() > 0){
                        parser.report_semantic_error(formParsleft, "Metoda main ne sme imati parametre.");
                    }
                    //Tab.currentScope().setLevel(numOfParameters);      //CHECK FORM PARS
                    currentMethod.setLevel(currentMethod.getLevel()+1); //CHECK is level ok...?
                    //TODO currentscope.setLevel(numPar);
                :}
                VarDeclList LBRACE
                {:
                    //TODO ovde ide gen koda za ulaz u metodu
                    inFunction = false;
                    //inMain = false;
                :}
                StatementList RBRACE
                {:
                    if(!returnFound && type != Tab.noType && inMain == false) //ovo je i za void
                        parser.report_error("Semanticka greska na liniji " + typeleft + ": funkcija " + funName + " nema RETURN iskaz", null); //CHECK return iskaz
                    inMain = false;
                    currentMethod = null;
                    returnFound = false;

                    Tab.chainLocalSymbols(Tab.find(funName));
                    Tab.closeScope();
                :};

FormPars ::= FormalParamList | /* epsilon */ ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl
					|
					FormalParamDecl
					;

FormalParamDecl ::= Type:type IDENT:ident
 {:
    numOfParameters++;
    if(Tab.currentScope().findSymbol(ident) == Tab.noObj)
    {
        parser.report_error("Greska na liniji " + typeleft + " vec postoji simbol sa imenom: " + ident, null);
        RESULT = Tab.noObj;
    }
    else
    {
        Tab.insert(Obj.Var, ident, type); //CHECK
    }
                                        //TODO numPar++;,   dodajes u scope metode ovaj iden
 :};

StatementList ::= StatementList Statement
					|
				  /* epsilon */
				  ;

Statement ::= Matched
				|
			  Unmatched ;

Unmatched ::= IF Expr Statement
			|
			IF Expr Matched ELSE Unmatched
			;


Matched ::= Designator:destination Assignop Expr:expression SEMI
            {:
                //TODO , provera za dodelu vr
                if(!expression.getType().assignableTo(destination.getType())){
                    parser.report_error("Greska na liniji: " + destinationleft + " : nekompatibilni tipovi u dodeli vrednosti", null); //CHECK THIS
                }

            :}
            |
            Designator EQUAL error SEMI
            {: parser.log.debug("Izraz tipa: nesto = XX; XX je lose. Uspesan oporavak od greske pri dodeli vrednosti."); :}
            |
            Designator PLUSPLUS SEMI
            {:
                //TODO   des mora da je int
            :}
            |
            Designator MINUSMINUS SEMI
            {:
                //TODO   des mora da je int
            :}
            |
            Designator:func LPAREN ActualPars RPAREN SEMI
            {:
                if (Obj.Meth == func.getKind())
                {
                    parser.report_info("[Matched]Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
                    RESULT = func.getType();
                }
                else{
                    parser.report_error("[Matched]Greska na liniji " + funcleft + " : ime " + func.getName() + " nije funkcija!", null);
                    RESULT = Tab.noType;
                }
            :}
            |
            READ LPAREN Designator:de RPAREN SEMI
            {:
               if(de.getKind() != Obj.Var && de.getKind() != Obj.Fld && de.getKind() != Obj.Elem){
                   parser.report_semantic_error(deleft, "Neocekivana kategorija simbola " + de.getName() +". Ocekivano: "+ "var elem ili field" +"; Dobijeno: "+ de.getType().getKind() +".");
               }
               if(de.getType().getKind() == Struct.Int || de.getType().getKind() == Struct.Bool && de.getType().getKind() == Struct.Char)
                    RESULT = de; //CHECK
               else{
                    parser.report_semantic_error(deleft, "Argumenti READ funkcije moraju biti [int,char,bool].");
                    RESULT = Tab.noObj;
               }
               //TODO de je variabla tipa int, bool ili char
            :}
            |
            PRINT LPAREN Expr:e COMMA NUMBER:num RPAREN SEMI
            {:
                if(e.getType().getKind() == Struct.Int || e.getType().getKind() == Struct.Bool && e.getType().getKind() == Struct.Char){
                        RESULT = e;
                }
                else {
                    parser.report_semantic_error(eleft, "Argumenti PRINT funkcije moraju biti [int,char,bool].");
                    RESULT = Tab.noObj;
                };
               //TODO: de je tipa int, bool ili char
               //Todo: num je tipa int
            :}
            |
            PRINT LPAREN Expr:e RPAREN SEMI
            {:
                if(e.getType().getKind() == Struct.Int){
                    mk.printCallCount++; //TODO: tipa int,...
                    RESULT = e;
                } else {
                    parser.report_semantic_error(eleft, "Argumenti PRINT funkcije moraju biti [int,char,bool].");
                    RESULT = Tab.noObj;
                }//CHECK RETURN
            :}
            |
            RETURN Expr:typeOfExpr SEMI
            {:
                returnFound = true;
                Obj currentMethodType = currentMethod;
                if(!currentMethodType.getType().compatibleWith(typeOfExpr.getType()))
                {
                    parser.report_error("Greska na liniji: " + typeOfExprleft + " : tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije: " + currentMethod.getName(), null);
                }
                //TODO expr je kompatibilno sa tipom metode
                //CHECK THIS
            :}
            |
            RETURN SEMI
            {:
               //TODO metoda je void
            :}
            |
            IF Expr Matched ELSE Matched
            |
            LBRACE StatementList RBRACE
            ;

//Condition ::= CondTerm
//              |
//              CondTerm OROR CondTerm;

//CondTerm ::= CondFact
//             |
//             CondFact ANDAND CondFact;

//CondFact ::= Expr
//			 |
//			 Expr Relop Expr;



Factor ::=  Designator:des
			{:
				RESULT = des;
			:}
		    |
		   	Designator:func LPAREN ActualPars RPAREN
		   	{:

				if (Obj.Meth == func.getKind())
				{
				    parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
				    RESULT = func;
                }
                else{
                    parser.report_error("Greska na liniji " + funcleft + " : ime " + func.getName() + " nije funkcija!", null);
                    RESULT = Tab.noObj;
                }
                //TODO: DA LI SE STVARNI PARAMETRI SLAZU SA FORMALNIM [dodati proveru] preko steka ovo ide
			:}
			|
			NUMBER:num
			{:
				RESULT = new Obj(Obj.Con, "", Tab.intType, num, Obj.NO_VALUE);
			:}
			|
			CHAR:c
			{:
				RESULT = new Obj(Obj.Con, "", Tab.charType, c, Obj.NO_VALUE);
			:}
			|
			BOOL:bo
			{:
				RESULT = new Obj(Obj.Con, "", MojaTabela.boolType, bo?1:0, Obj.NO_VALUE);
			:}
			|
			NEW Type:t
			{:
				if(t.getKind() != Struct.Class){
					parser.report_error("Greska na liniji " + tleft + " nije klasnog tipa", null);
					RESULT = Tab.noObj; //NULL...
				}
				else
				{
					RESULT = new Obj(Obj.Var,"",t);
				}
			:}
			|
			NEW Type:tname SQUAREBRACKETLEFT Expr:expr SQUAREBRACKETRIGHT
			{:
			    //parser.log.debug("NEW Tip: " + tname.getKind());
				if(expr.getType() != Tab.intType){
					parser.report_error("Greska na liniji " + tnameleft + " nije int tip[example: new int[5]]", null);
					RESULT = Tab.noObj; //NULL...
				  }
				else {
					Struct struct = new Struct(Struct.Array, tname);
					RESULT = new Obj(Obj.Var, "", struct);
				}
			:}
			|
			LPAREN Expr:expr RPAREN
			{:
			    RESULT=expr;
			:}
		   ;

ActualPars ::= ActualParamList
				|
			   /* epsilon */
			   ;

ActualParamList ::= ActualParamList COMMA Expr //TODO ovde je jebada, moras da imas svoj stek u kome sacuvaj ove tipove
					|
					Expr
					;

Designator ::=  IDENT:ident
                {:
                 Obj obj=Tab.find(ident);

                if(obj == Tab.noObj) {
                    parser.report_error("Greska na liniji " + identleft + " : ime " + ident + " nije deklarisano!", null);
                }

                if(obj.getKind()!=Obj.Var && obj.getKind()!=Obj.Con && obj.getKind()!=Obj.Meth ){
                    parser.report_error("Greska na liniji "+ " nije var, con, meth!!!!!!!!!!!"+obj.getKind(), null);
                    RESULT = Tab.noObj; //NULL...
                }else
                    RESULT=obj;

                :}
				|
				Designator DOT IDENT:ident
				{:
				    //nije ok, ako budem radio KLASE treba...
                    RESULT=Tab.find(ident);
                :}
				|
				Designator:des
				{:
                    if(des != Tab.noObj){
                        if(des.getType().getKind() != Struct.Array){
                            parser.report_semantic_error(desleft,"Simbol "+ des.getName()+  " ne predstavlja niz.");
                        }
                    }
				:}
				SQUAREBRACKETLEFT Expr:expr SQUAREBRACKETRIGHT
				{:
				    RESULT = Tab.noObj; //CHECK [1]
                    if(des != Tab.noObj){
                        boolean arrOk = true;
                        if(des.getType().getKind() != Struct.Array){
                            arrOk = false;
                        }
                        if(expr.getType() != Tab.intType){
                            parser.report_error("Tipovi se ne poklapaju! 1: " + des + " 2: " + expr, null);
                            arrOk = false;
                        }

                        if(arrOk){
                            parser.log.debug("Designator tip(3 je array): " + des.getType().getKind() + " Expression tip(1 je int): " + expr.getType().getKind());
                            RESULT = new Obj(Obj.Elem, des.getName()+"[]", des.getType().getElemType(), des.getAdr(), des.getLevel());
                        }
                    }

				/*
                    //TODO[1]:  des treba da bude tipa array a expr tipa int
				    if(des.getType().getKind() == Struct.Array && expr.getType().getKind() == Struct.Int)
				    {
				        RESULT = des;
				    }
				    Struct elemType = des.getType().getElemType();
				    if(elemType.getKind() == Struct.Int){
				        Obj obj = new Obj(Obj.Var, "", Tab.intType);
				        RESULT = obj;
				    }
				    else
				        RESULT = des;   // TODO[1]: vraca tip elem niza elemType a tipa elemType za niz tipa int vraca int
				        */
				:};

Assignop ::= EQUAL | AddopRight | MulopRight;
//Relop ::= EQUALEQUAL | NOTEQUAL | MORE | MOREOREQUAL | LESS | LESSOREQUAL;

Expr ::= ComboExpr:expr
        {:  //nije int && nije char && nije bool
            if(expr.getType() != Tab.intType && expr.getType() != Tab.charType && expr.getType() != MojaTabela.boolType && expr.getType().getKind() != Struct.Array){
                parser.log.debug("Tip: " + expr.getType().getKind());
                parser.report_error("Greska na liniji " + exprleft + " nije int tipa | ID[1] => " + expr.getType().getKind(), null);
                RESULT = Tab.noObj;
            } else
                RESULT = expr;
        :}
         |
         MINUS ComboExpr:expr
         {:
            if(expr.getType() != Tab.intType){
                parser.report_error("Greska na liniji " + exprleft + " nije int tipa | ID[2]", null);
                RESULT = Tab.noObj;
            } else{
                RESULT = expr;
            }
         :};

ComboExpr ::=   AddTerm:addTerm CombOp ComboExpr:comboExpr
                {:
                    if(addTerm.getKind() != Obj.Var && addTerm.getKind() != Obj.Elem){
                        parser.report_error("Greska na liniji " + addTermleft+ " nije varijabla(neocekivana kategorija simbola)", null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else if(addTerm.getType() != Tab.intType || comboExpr.getType() != Tab.intType){
                        parser.report_error("Greska na liniji " + addTermleft + " nije int tipa | ID[3]" + "addterm tip:" + addTerm.getType().getKind() + "comboExpr tip: " + comboExpr.getType().getKind(), null); //bodovi = (niz[1]/=niz[0]);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                        if(addTerm.getType().equals(comboExpr.getType()) && comboExpr.getType() == Tab.intType)
                            RESULT = addTerm;
                        else
                        {
                            parser.report_error("Greska na liniji " + comboExprleft + " : nekompatibilni tipovi u izrazu za sabiranje. + [" + addTerm.getType().getKind() + "][" + comboExpr.getType().getKind() + "]", null);
                            RESULT = Tab.noObj; //Tab.noType u videu...
                        }
                    }
                :}
				|
				AddTerm:addTerm
				{:
				    RESULT=addTerm;
				:};

AddTerm ::= AddTerm:addTerm AddopLeft Term:term
            {:
                if(addTerm.getType() != Tab.intType ||  term.getType() != Tab.intType){
                    parser.report_error("Greska na liniji " + addTermleft + " nije int tipa | ID[4]", null);
                    RESULT = Tab.noObj; //NULL...
                } else{
                    RESULT = term;
                }
            :}
			|
            Term:term
            {:
                RESULT=term;
            :};

Term ::= Term:term MulopLeft Factor:factor
         {:
            if(factor.getType() != Tab.intType || term.getType() != Tab.intType){
                parser.report_error("Greska na liniji " + termleft + " nije int tipa!", null);
                RESULT = Tab.noObj; //NULL...
            } else{
                RESULT = factor;
            }
        :}
		|
		Factor:factor
		{:
		    RESULT=factor;
		:}
		;

CombOp ::= AddopRight:addri
            {:
                RESULT = addri;
            :}
		   |
		   MulopRight:mu
		   {:
		    RESULT = mu;
		   :};


Addop ::=   AddopLeft | AddopRight
            {:
                 //TODO: fale svuda RESULT i vracaj COode.add .... Code.eq
            :};
AddopLeft ::= PLUS {: RESULT = Code.add; :}
              |
              MINUS {: RESULT = Code.sub; :};
AddopRight ::= PLUSEQUAL {: RESULT = Code.add; :}
               |
               MINUSEQUAL {: RESULT = Code.sub; :};

Mulop ::= MulopLeft | MulopRight;
MulopLeft ::=   MUL {: RESULT = Code.mul; :}
                |
                DIV {: RESULT = Code.div; :}
                |
                MOD {: RESULT = Code.rem; :};
MulopRight ::=  MULEQUAL
                {:
                    RESULT = Code.mul;
                :}
                |
                DIVEQUAL
                {:
                    RESULT = Code.div;
                :}
                |
                MODEQUAL
                {:
                    RESULT = Code.rem;
                :};
 
			  