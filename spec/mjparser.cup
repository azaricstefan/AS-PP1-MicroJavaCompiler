package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.as.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;


parser code {:


	Logger log = Logger.getLogger(getClass());
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
    MojaTabela.mojaInicijalizacija();
	//Tab.init(); // Universe scope
:}

action code {:
	Obj currentMethod = null;
	MojaKlasa mk = new MojaKlasa();


	boolean inFunction = false;
	boolean inMain = false;
	Struct constType = null;

	boolean returnFound = false;

    //da li je ime deklarisano u trenutnom opsegu
    boolean checkName(String name){
        return Tab.currentScope().findSymbol(name) == null;
    }
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ;
terminal RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUALEQUAL, NOTEQUAL, LESS, LESSOREQUAL, AND, OR;
terminal EQUAL, PLUSEQUAL, MINUSEQUAL, DIVEQUAL, MODEQUAL, PLUSPLUS, MINUSMINUS;
terminal SEMI, COMMA, DOT, SQUAREBRACKETLEFT, SQUAREBRACKETRIGHT, LBRACE, RBRACE, LPAREN, RPAREN;
terminal ANDAND, OROR, MOREOREQUAL, MORE, MULEQUAL;

terminal Boolean BOOL;
terminal Character CHAR;
terminal Integer NUMBER ;
terminal String IDENT ;


non terminal Program, MethodDeclList, MethodDecl;
non terminal VarDeclList, VarDecl,DeclList, ConstDecl, ClassDecl, ConstDeclList, ConstVal;
non terminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList;
non terminal StatementList, Statement;
non terminal Struct Type;
/*
NON TERMINAL OBJECTS
*/
non terminal Obj Designator, Factor, Expr, Term, MethodType, ComboExpr, AddTerm;


non terminal Unmatched, Matched;
non terminal VarDecElem, VarDecElemList;
non terminal Assignop, Relop;
non terminal Condition, CondTerm, CondFact;
non terminal Integer Addop, AddopLeft, AddopRight, Mulop, MulopRight, MulopLeft , CombOp;



Program ::= PROG IDENT:pName
            {:
                MojaTabela.insert(Obj.Prog,pName,Tab.noType);
                Tab.openScope();
            :}
            DeclList LBRACE MethodDeclList RBRACE
            {:
                Tab.chainLocalSymbols(Tab.find(pName));
                Tab.closeScope();
                Tab.dump(new MojTableVisitor());
            :} ;

VarDeclList ::= VarDeclList VarDecl
				|
				/* epsilon */
				;
DeclList ::= DeclList VarDecl
				|
				DeclList ConstDecl
				|
				DeclList ClassDecl
				|
				/* epsilon */
				;
                VarDecl ::= Type:cType
                {:
                    constType = cType;
                :}
                VarDecElemList SEMI;
VarDecElem ::= IDENT:varName
                {:
                    //parser.report_error("****************************************" + varName, null);
                    if(inFunction != true){
                        mk.globalVars++;
                    }
                    if(inMain == true){
                        mk.inMainVars++;
                    }
                    if(Tab.currentScope().findSymbol(varName) != null)
                    {
                        parser.report_error("Greska na liniji " + varNameleft + " vec postoji simbol sa imenom: " + varName, null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                        Tab.insert(Obj.Var, varName, constType);
                    }
                :}
                |
                IDENT:varName SQUAREBRACKETLEFT SQUAREBRACKETRIGHT
                {:
                    if(inFunction != true){
                        mk.globalVars++;
                    }
                    if(inMain == true){
                        mk.inMainVars++;
                    }
                    if(Tab.currentScope().findSymbol(varName) != null)
                    {
                           parser.report_error("Greska na liniji " + varNameleft + " vec postoji simbol sa imenom: " + varName, null);
                           RESULT = Tab.noObj; //NULL...
                       }
                       else
                       {
                           Tab.insert(Obj.Var, varName,new Struct(Struct.Array, constType));
                       }
                   :};

VarDecElemList ::=  VarDecElem COMMA VarDecElemList
					|
					VarDecElem
					|
					error:err COMMA VarDecElemList
					{:

						parser.report_error("Sintaksna greska na liniji " + errleft + " pogresna deklaracija globalne promenljive | ZAREZ!" , null);
						parser.report_info("Uspesan oporovak od greske na liniji" + errleft + "."  , null);
					:}
					|
					error:err
					{:
						parser.report_error("Sintaksna greska na liniji " + errleft + " pogresna deklaracija globalne promenljive!" , null);
						parser.report_info("Uspesan oporovak od greske na liniji" + errleft + "."  , null);
					:}
					;



ConstVal ::= NUMBER
            {:
                mk.globalConsts++;
                RESULT = Tab.intType;
            :}
			 |
			 BOOL
            {:
                mk.globalConsts++;
                RESULT = MojaTabela.boolType;
            :}
			 |
			 CHAR
            {:
                mk.globalConsts++;
                RESULT = Tab.charType;
            :}
			 ;
ConstDecl ::= CONST Type:cType
                {:
                    constType = cType;
                :}
                ConstDeclList SEMI;

ConstDeclList ::= IDENT:constName EQUAL ConstVal:type
                    {:
                        if(type != constType)
                        {
                            parser.report_error("Greska na liniji " + constNameleft + " nekompatibilni tipovi", null);
                            RESULT = Tab.noObj; //NULL...
                        }
                        else if(Tab.currentScope().findSymbol(constName) == Tab.noObj)
                        {
                            parser.report_error("Greska na liniji " + constNameleft + " vec postoji simbol sa imenom: " + constName, null);
                            RESULT = Tab.noObj; //NULL...
                        }
                        else
                        {
                            Tab.insert(Obj.Con, constName, constType);
                        }
                    :}
                    COMMA ConstDeclList
				  |
				  IDENT:constName EQUAL ConstVal:type
				  {:
                    if(type != constType)
                    {
                        parser.report_error("Greska na liniji " + typeleft + " nekompatibilni tipovi", null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else if(Tab.currentScope().findSymbol(constName) == Tab.noObj)
                    {
                        parser.report_error("Greska na liniji " + typeleft + " vec postoji simbol sa imenom: " + constName, null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else
                    {
                    Tab.insert(Obj.Con, constName, constType);
                    }
				  :}
				  ;

Type ::= IDENT:ident
		{:
		    Obj obj = Tab.find(ident);
		    if(obj.getKind() != Obj.Type)
		    {
		         parser.report_error("Greska na liniji " + identleft+ ":"  + ident + " nije tip", null);
		         RESULT=Tab.noType;
		    }
		    else
		        RESULT = obj.getType();
		:} ;

MethodType ::= Type
			   |
			   VOID;

MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::=  MethodType:type IDENT:funName
                {:
                    MojaTabela.insert(Obj.Meth,funName,Tab.noType);
                    Tab.openScope();
                :}
                LPAREN
                {:
                    inFunction = true;
                    if(funName.equals("main")){
                        inMain = true;
                    }
                :}
                FormPars RPAREN
                VarDeclList LBRACE
                {:
                    inFunction = false;
                    inMain = false;
                :}
                StatementList RBRACE
                {:
                    Tab.chainLocalSymbols(Tab.find(funName));
                    Tab.closeScope();
                :};

FormPars ::= FormalParamList | /* epsilon */ ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl
					|
					FormalParamDecl
					;

FormalParamDecl ::= Type IDENT ;

StatementList ::= StatementList Statement
					|
				  /* epsilon */
				  ;

Statement ::= Matched
				|
			  Unmatched ;

Unmatched ::= IF Expr Statement
			|
			IF Expr Matched ELSE Unmatched
			;


Matched ::= Designator Assignop Expr SEMI
			  |
			  Designator EQUAL error SEMI
			  {: parser.log.debug("Izraz tipa: nesto = XX; XX je lose. Uspesan oporavak od greske pri dodeli vrednosti."); :}
			  |
			  Designator PLUSPLUS SEMI
			  |
			  Designator MINUSMINUS SEMI
			  |
			  Designator LPAREN ActualPars RPAREN SEMI
			  |
			  READ LPAREN Designator RPAREN SEMI
			  |
			  PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
			  |
			  PRINT LPAREN Expr RPAREN SEMI
			  {: mk.printCallCount++; :}
			  |
			  RETURN Expr SEMI
			  |
			  RETURN SEMI
			  |
			  IF Expr Matched ELSE Matched
			  |
			  LBRACE StatementList RBRACE
			  ;

Condition ::= CondTerm
              |
              CondTerm OROR CondTerm;

CondTerm ::= CondFact
             |
             CondFact ANDAND CondFact;

CondFact ::= Expr
			 |
			 Expr Relop Expr;



Factor ::=  Designator:des
			{:
				RESULT = des;
			:}
		    |
		   	Designator:des LPAREN ActualPars RPAREN
		   	{:
				RESULT = des;
			:}
			|
			NUMBER:num
			{:
				RESULT = new Obj(Obj.Con, "", Tab.intType, num, Obj.NO_VALUE);
			:}
			|
			CHAR:c
			{:
				RESULT = new Obj(Obj.Con, "", Tab.charType, c, Obj.NO_VALUE);
			:}
			|
			BOOL:bo
			{:
				RESULT = new Obj(Obj.Con, "", MojaTabela.boolType, bo?1:0, Obj.NO_VALUE);
			:}
			|
			NEW Type:t
			{:
				if(t.getKind() != Struct.Class){
					parser.report_error("Greska na liniji " + tleft + " nije klasnog tipa", null);
					RESULT = Tab.noObj; //NULL...
				}
				else
				{
					RESULT = new Obj(Obj.Var,"",t);
				}
			:}
			|
			NEW Type:tname SQUAREBRACKETLEFT Expr:expr SQUAREBRACKETRIGHT
			{:
			    //parser.log.debug("NEW Tip: " + tname.getKind());
				if(expr.getType() != Tab.intType){
					parser.report_error("Greska na liniji " + tnameleft + " nije int tip[example: new int[5]]", null);
					RESULT = Tab.noObj; //NULL...
				  }
				else {
					Struct struct = new Struct(Struct.Array, tname);
					RESULT = new Obj(Obj.Var, "", struct);
				}
			:}
			|
			LPAREN Expr:expr RPAREN
			{:
			    RESULT=expr;
			:}
		   ;

ActualPars ::= ActualParamList
				|
			   /* epsilon */
			   ;

ActualParamList ::= ActualParamList COMMA Expr
					|
					Expr
					;

Designator ::=  IDENT:ident
                {:
                 Obj obj=Tab.find(ident);

                if(obj.getKind()!=Obj.Var && obj.getKind()!=Obj.Con && obj.getKind()!=Obj.Meth ){
                    parser.report_error("Greska na liniji "+ " nije var, con, meth!!!!!!!!!!!"+obj.getKind(), null);
                    RESULT = Tab.noObj; //NULL...
                }else
                    RESULT=obj;

                :}
				|
				Designator DOT IDENT:ident
				{:
				    //nije ok, ako budem radio KLASE treba...
                    RESULT=Tab.find(ident);
                :}
				|
				Designator:des SQUAREBRACKETLEFT Expr:expr SQUAREBRACKETRIGHT
				{:
				    //nadji element tipa i vrati taj TYPE!
				    Struct elemType = des.getType().getElemType();
				    if(elemType.getKind() == Struct.Int){
				        Obj obj = new Obj(Obj.Var, "", Tab.intType);
				        RESULT = obj;
				    } else
				    //parser.report_error("Designator NIZ: tip elementa:" + elemType.getKind(),null);
				    RESULT = des;
				:};

Assignop ::= EQUAL | AddopRight | MulopRight;
Relop ::= EQUALEQUAL | NOTEQUAL | MORE | MOREOREQUAL | LESS | LESSOREQUAL;

Expr ::= ComboExpr:expr
        {:
            //nije int && nije char && nije bool
            if(expr.getType() != Tab.intType && expr.getType() != Tab.charType && expr.getType() != MojaTabela.boolType){
                parser.log.debug("Tip: " + expr.getType().getKind());
                //TODO: provera getElemType
                parser.report_error("Greska na liniji " + exprleft + " nije int tipa | ID[1] => " + expr.getType().getKind(), null);
                RESULT = Tab.noObj; //NULL...
            } else{
                RESULT = expr;
            }
                //RESULT = expr;
        :}
         |
         MINUS ComboExpr:expr
         {:
            if(expr.getType() != Tab.intType){
                parser.report_error("Greska na liniji " + exprleft + " nije int tipa | ID[2]", null);
                RESULT = Tab.noObj; //NULL...
            } else{
                RESULT = expr;
            }
         :};

ComboExpr ::=   AddTerm:addTerm CombOp ComboExpr:comboExpr
                {:
                    if(addTerm.getKind() != Obj.Var && addTerm.getKind() != Obj.Elem){
                        parser.report_error("Greska na liniji " + addTermleft+ " nije varijabla(neocekivana kategorija simbola)", null);
                        RESULT = Tab.noObj; //NULL...
                    }
                    else if(addTerm.getType() != Tab.intType || comboExpr.getType() != Tab.intType){
                        parser.report_error("Greska na liniji " + addTermleft + " nije int tipa | ID[3]" + "addterm tip:" + addTerm.getType().getKind() + "comboExpr tip: " + comboExpr.getType().getKind(), null); //bodovi = (niz[1]/=niz[0]);
                        RESULT = Tab.noObj; //NULL...
                    } else{
                     RESULT = addTerm;
                    }
                :}
				|
				AddTerm:addTerm
				{:
				    RESULT=addTerm;
				:};

AddTerm ::= AddTerm:addTerm AddopLeft Term:term
            {:
                if(addTerm.getType() != Tab.intType ||  term.getType() != Tab.intType){
                    parser.report_error("Greska na liniji " + addTermleft + " nije int tipa | ID[4]", null);
                    RESULT = Tab.noObj; //NULL...
                } else{
                    RESULT = term;
                }
            :}
			|
            Term:term
            {:
                RESULT=term;
            :};

Term ::= Term:term MulopLeft Factor:factor
         {:
            if(factor.getType() != Tab.intType || term.getType() != Tab.intType){
                parser.report_error("Greska na liniji " + termleft + " nije int tipa!", null);
                RESULT = Tab.noObj; //NULL...
            } else{
                RESULT = factor;
            }
        :}
		|
		Factor:factor
		{:
		    RESULT=factor;
		:}
		;

CombOp ::= AddopRight:addri
            {:
                RESULT = addri;
            :}
		   |
		   MulopRight:mu
		   {:
		    RESULT = mu;
		   :};


Addop ::= AddopLeft | AddopRight;
AddopLeft ::= PLUS | MINUS;
AddopRight ::= PLUSEQUAL | MINUSEQUAL;

Mulop ::= MulopLeft | MulopRight;
MulopLeft ::= MUL | DIV | MOD;
MulopRight ::= MULEQUAL | DIVEQUAL | MODEQUAL;
 
			  